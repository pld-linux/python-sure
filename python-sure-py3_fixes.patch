diff --git a/README.md b/README.md
index 3714d29..efda4a5 100644
--- a/README.md
+++ b/README.md
@@ -32,7 +32,6 @@ import sure
 
 (4).should.be.equal(2 + 2)
 (7.5).should.eql(3.5 + 4)
-(2).should.equal(8 / 4)
 
 (3).shouldnt.be.equal(5)
 ```
diff --git a/setup.py b/setup.py
index a4877f6..778f8c8 100755
--- a/setup.py
+++ b/setup.py
@@ -18,6 +18,7 @@
 
 import ast
 import os
+import sys
 from setuptools import setup, find_packages
 
 
@@ -41,8 +42,10 @@ def read_version():
     return finder.version
 
 
-local_file = lambda *f: \
-    open(os.path.join(os.path.dirname(__file__), *f)).read()
+def local_file( *f):
+    if sys.version_info < (3, 0, 0):
+        return open(os.path.join(os.path.dirname(__file__), *f)).read()
+    return open(os.path.join(os.path.dirname(__file__), *f), encoding="utf-8").read()
 
 
 install_requires = ['mock', 'six']
diff --git a/sure/old.py b/sure/old.py
index 70822e1..13a3f74 100644
--- a/sure/old.py
+++ b/sure/old.py
@@ -42,10 +42,10 @@ from sure.core import itemize_length
 
 
 def identify_callable_location(callable_object):
-    filename = os.path.relpath(callable_object.func_code.co_filename)
-    lineno = callable_object.func_code.co_firstlineno
-    callable_name = callable_object.func_code.co_name
-    return b'{0} [{1} line {2}]'.format(callable_name, filename, lineno)
+    filename = os.path.relpath(callable_object.__code__.co_filename)
+    lineno = callable_object.__code__.co_firstlineno
+    callable_name = callable_object.__code__.co_name
+    return '{0} [{1} line {2}]'.format(callable_name, filename, lineno).encode()
 
 
 def is_iterable(obj):
diff --git a/tests/test_assertion_builder.py b/tests/test_assertion_builder.py
index 3e1cd8e..7e833e6 100644
--- a/tests/test_assertion_builder.py
+++ b/tests/test_assertion_builder.py
@@ -648,13 +648,19 @@ def test_throw_matching_regex():
         raise RuntimeError('should not have reached here')
 
     except AssertionError as e:
-        expect(str(e)).to.equal("When calling 'blah [tests/test_assertion_builder.py line 633]' the exception message does not match. Expected to match regex: u'invalid regex'\n against:\n u'this message'")
+        if PY3:
+            expect(str(e)).to.equal("When calling b'blah [tests/test_assertion_builder.py line 633]' the exception message does not match. Expected to match regex: 'invalid regex'\n against:\n 'this message'")
+        else:
+            expect(str(e)).to.equal("When calling 'blah [tests/test_assertion_builder.py line 633]' the exception message does not match. Expected to match regex: u'invalid regex'\n against:\n u'this message'")
 
     try:
         expect(blah).when.called_with(1).should.throw(ValueError, re.compile(r'invalid regex'))
         raise RuntimeError('should not have reached here')
     except AssertionError as e:
-        expect(str(e)).to.equal("When calling 'blah [tests/test_assertion_builder.py line 633]' the exception message does not match. Expected to match regex: u'invalid regex'\n against:\n u'this message'")
+        if PY3:
+            expect(str(e)).to.equal("When calling b'blah [tests/test_assertion_builder.py line 633]' the exception message does not match. Expected to match regex: 'invalid regex'\n against:\n 'this message'")
+        else:
+            expect(str(e)).to.equal("When calling 'blah [tests/test_assertion_builder.py line 633]' the exception message does not match. Expected to match regex: u'invalid regex'\n against:\n u'this message'")
 
 def test_should_not_be_different():
     ("'something'.should_not.be.different('SOMETHING'.lower())")
